<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>Cleaners&#39; Blog | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Cleaners&#39; Blog</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            计算机网络
        </div>
        <div class="post-meta">
            2022-06-04
        </div>
    

    <div class="post-md">
        <p><img src="/../pic/blog_computer_network.jpg" alt="计算机网络"></p>
<blockquote>
<p>主要参考经典教材与本科期间个人所学，基于目前广泛使用的TCP&#x2F;IP协议族，自顶向下分析各个常见网络协议及其安全问题</p>
</blockquote>
<p>[toc]</p>
<h1><span id="应用层">应用层</span></h1><h2><span id="dns">DNS</span></h2><p>《计算机网络-自顶向下方法》P87</p>
<h3><span id="解决的问题">解决的问题</span></h3><p>DNS协议又叫域名解析协议，是因特网目录服务中的核心协议。<br>因特网目录服务的产生是为了解决大规模网络环境中32位的IP地址难以管理的问题，通过<strong>分布式、层次化的数据库系统</strong>维护用户易于记忆的域名和IP协议能够识别的主机IP地址之间的<strong>映射关系</strong>。DNS系统的结构如下：<br><img src="/../pic/blog_computer_network_DNS2.jpg" alt="DNS系统结构"><br>DNS协议的作用就是提供这种域名到IP地址的转换（<strong>域名解析</strong>）</p>
<h3><span id="报文格式">报文格式</span></h3><p><img src="/../pic/blog_computer_network_DNS1.jpg" alt="DNS报文"><br>具体细节参考《计算机网络-自顶向下方法》P94-p95</p>
<h3><span id="协议运转">协议运转</span></h3><p>域名对应主机，采用树状结构命名，不同域名等级之间用”.”分隔，从左至右，域名等级逐渐提升，解析过程从右至左，一级解析一部分。<br>DNS中有两种解析方式：</p>
<ul>
<li>递归：主机到本地域名服务器为递归查询</li>
<li>迭代：本地DNS服务器到根DNS服务器、顶级域DNS服务器、权威DNS服务器为迭代查询</li>
</ul>
<h3><span id="安全攻击">安全攻击</span></h3><p><img src="/../pic/blog_computer_network_DNS3.jpg" alt="针对DNS的安全攻击"></p>
<ul>
<li>欺骗、劫持和钓鱼都是建立在中间人攻击的基础上，由于中间人对PC的响应更快，PC会丢弃真正的响应包（签名）</li>
<li>缓存投毒指的是通过虚假的DNS查询响应数据包，使本地DNS服务器缓存错误的映射关系，可以通过使用随机的子域名发起查询，并冒充更高级别的域名服务器发送响应报文，毒化更高级别的域名IP地址。（采用公钥密码进行签名、随机端口）</li>
<li>还可以通过DOS攻击破坏服务器可用性（在服务器部署防dos插件（汝Fail2Ban）即可）</li>
</ul>
<h2><span id="http">Http</span></h2><p>《计算机网络-自顶向下方法》P65</p>
<h3><span id="解决的问题">解决的问题</span></h3><p>web应用已经是大多数用户接入因特网的主要方式，能够按需主动搜索得到想要的信息<br>http是web应用的应用层协议，主要解决web应用中本地主机与远程主机超文本（图片、文本、音频等）传输的问题</p>
<h3><span id="报文格式">报文格式</span></h3><p>现行网络环境下的http绝大多数都通过TLS加密，通过Wireshark无法抓包查看</p>
<h4><span id="请求报文">请求报文：</span></h4><p><img src="/../pic/blog_computer_network_http2.jpg" alt="http请求报文格式"><br><img src="/../pic/blog_computer_network_http3.png" alt="http请求报文抓包"><br>请求报文分为三个部分：</p>
<ol>
<li>请求行：方法（get、post、head、options、put、delete、connect）</li>
<li>首部行：请求行之外的键值对</li>
<li>实体主体：传输的数据，比如Post方法携带的数据，get方法此部分为空</li>
</ol>
<p>响应报文：<br><img src="/../pic/blog_computer_network_http1.jpg" alt="http响应报文格式"><br><img src="/../pic/blog_computer_network_http4.jpg" alt="http响应报文抓包"><br>分为三个部分：</p>
<ol>
<li>状态行：版本、状态码、短语（OK、NOT FOUND等）</li>
<li>首部行：键值对</li>
<li>实体体：响应的数据</li>
</ol>
<h3><span id="请求方法">请求方法</span></h3><p>http有8种请求方法，最常见的为以下2种</p>
<h4><span id="get">Get</span></h4><p>GET方法用于使用给定的URI从给定服务器中<strong>检索信息</strong>，即从指定资源中<strong>请求数据</strong>。<br>使用GET方法的请求应该只是检索数据，并且<strong>不应对数据产生其他影响</strong>。<br>Get数据位于url上，可以缓存，没有长度限制（但是浏览器对url有长度限制），处理敏感数据时不能用Get</p>
<h4><span id="post">Post</span></h4><p>POST方法用于<strong>将数据发送到服务器</strong>以创建或更新资源，它要求服务器确认请求中包含的内容作为由URL区分的Web资源的另一个下属。</p>
<p>POST请求不会被缓存，请求对数据长度没有限制；无法从浏览器历史记录中查找到POST请求。</p>
<h3><span id="状态维持">状态维持</span></h3><p>http是一个无状态的协议，也就是说用户对同一个服务器不同页面的访问是无关的，这与用户在网页上的顺序操作流程是冲突的（如：登录 &#x3D;&#x3D;&gt; 获得个人数据 &#x3D;&#x3D;&gt;修改个人数据），所以需要用一定的机制解决这一问题。最基本的解决方案就使用Cookie</p>
<h4><span id="cookie">Cookie</span></h4><ol>
<li>用户首次访问服务器时由服务器生成，直接用键值对保存用户信息</li>
<li>首次http返回消息的首部行中携带，发送给客户端，并由客户端（一般是浏览器）保存</li>
<li>用户再次发起访问时在http首部行中携带cookie，服务器得到cookie得到用户身份信息，返回用户个性化页面</li>
</ol>
<h4><span id="非cookie的状态维持">非cookie的状态维持</span></h4><p>基于cookie扩展的状态维持主要思路是把cookie作为一个传输身份认证信息的容器，改变身份认证的机制，避免客户端保存直接的用户数据</p>
<ol>
<li><strong>Session</strong>： 针对于每一次会话，服务器通过用户信息生成一个键值对，键为与用户身份一一对应的sessionId，值为用户的身份信息，客户端只用保存SessionId，处理后续请求时服务器通过sessionId即可获得用户个人数据，避免了用户个人信息泄露，可以结合数据库缓存技术。<br>session机制可以脱离cookie实现。</li>
<li><strong>Token</strong>：将用户信息通过拼接、签名、完整性Hash值、加密等技术处理之后在客户端保存，避免用户信息泄露，服务器收到后进行解密、验证完整性、验证签名、得到拼接数据，即可得到用户个人信息。<br>需要说明对于session和token的传输时保存需要谨慎设置，比如放到cookie中容易收到CSRF攻击<h3><span id="web缓存">web缓存</span></h3>web缓存器也叫做代理服务器，是在一定场景下代替web服务器对web请求做出响应的中间（Client和Server之间）web实体。配置web缓存服务器的好处有：</li>
<li>减少请求响应时间</li>
<li>减少公网上的流量，改善整个网络性能<h4><span id="缓存场景下web请求响应过程">缓存场景下web请求响应过程</span></h4><strong>最原始场景：</strong></li>
<li>请求发送到web缓存</li>
<li>缓存检查是否有被请求的对象<blockquote>
<p>web缓存中有对应的对象，直接通过缓存进行响应<br>web缓存中没有对应的对象，缓存向web服务器发起请求，收到来自服务器的响应后缓存器响应最初web请求并将响应对象缓存起来</p>
</blockquote>
</li>
</ol>
<p>缓存器和服务器的对象往往存在时效性不一致问题，比如服务器数据更新后缓存器并没有更新，所以原始场景下长期存储对象并直接进行响应的做法在大部分场景下是不合理的</p>
<p><strong>条件GET：</strong></p>
<p><strong>设置：</strong></p>
<blockquote>
<ol>
<li>缓存中记录缓存对象最后一次修改时间。</li>
<li>有缓存时，缓存器向服务器发起条件Get请求（首部行包含If-Modified-Since），用于查询当前缓存的对象是否被更新</li>
<li>服务器收到这个请求报文有两个动作：</li>
</ol>
<ul>
<li>有更新：返回最新数据，包含修改时间</li>
<li>没有更新：返回实体部分为空（即只包含状态行和首部行的响应）</li>
</ul>
</blockquote>
<h2><span id="其他">其他</span></h2><p>应用层除了DNS和Http之外还有其他重要的经典协议，比如FTP、SMTP，同时也随着计算机网络的发展，不断涌现出新的协议。但是作为基础而言，DNS和Http 是使用最多，也就成为为了重要的两个协议，需要重点掌握。<br>以后涉及相关工作任务，还会来补充这部分内容。未完待续~</p>
<h1><span id="传输层">传输层</span></h1><p>为应用层服务<br>提供不同主机的进程之间的逻辑通信</p>
<h2><span id="套接字编程">套接字编程</span></h2><p>众所周知，传输层是为应用层（包括协议和具体应用）服务的。具体是通过什么方式实现的服务，答案便是套接字。<br>套接字是进程与网络通信的抽象，可以理解为通过套接字，主机上的进程能够实现与网络之间的通信。在主机上标识一个套接字的方式便是通过网络端口Port实现。<br>根据调用的传输层协议，套接字可以分为TCP套接字和UDP套接字。</p>
<h3><span id="多路分解和多路复用">多路分解和多路复用</span></h3><p>多路分解和多路复用是套接字实现的网络与进程通信的相辅相成的两种方式。<br>多路复用：源主机上多个进程将报文段封装上首部信息后发送给网络<br>多路分解：目的主机上通过首部信息将报文段分发给对应的进程</p>
<h2><span id="tcp">TCP</span></h2><p>TCP提供 <strong>面向连接</strong> 、<strong>可靠</strong> 、<strong>基于字节流</strong> 的服务</p>
<h3><span id="面向连接">面向连接</span></h3><p>面向连接实质上是维护了分组之间的关系，基于面向连接能够知道哪些分组丢失了，哪些分组需要重传，也能够清晰的掌握分组之间的顺序。<br>而无连接协议中，各个数据报之间是独立的，协议对每个数据报都尽量传输到指定的对端。<br>总的来讲，面向连接能够提供更高的可靠性。但是面向连接需要一个建立连接的过程，这也就导致了一定的耗时，同时也带来了一定的安全性风险。</p>
<h4><span id="三次握手">三次握手</span></h4><ol>
<li>客户端发起seq&#x3D;x的请求，SYN置1</li>
<li>服务端返回一个ACK&#x3D;x+1的响应，然后发起seq&#x3D;y，SYN置1的请求</li>
<li>客户端返回一个ACK&#x3D;y+1<br>第一次握手成功表明客户端发送数据的能力正常<br>第二次握手完成表明服务端接收数据和发送数据的能力正常<br>第三次握手完成表明客户端接收数据的能力正常</li>
</ol>
<p>如果只完成两次握手，无法知道客户端接收数据的能力正常</p>
<p>在第三次握手的过程中，由于客户端已经知道服务端接收数据的能力正常，所以第三次握手的包可以携带数据，前两次握手由于不知道对端接收数据的能力是否正常，不能携带数据</p>
<h4><span id="四次挥手">四次挥手</span></h4><p>首先需要明确一点，TCP连接是一个全双工的连接，允许数据向两个方向传输。TCPl连接是一个全双工连接，因此断开连接需要把两个方向的连接都断掉</p>
<ol>
<li>客户端发起连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），终止发送数据，进入FIN_WAIT1状态，等待服务器确认</li>
<li>服务器收到FIN，发送确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），进入CLOSE_WAIT状态。此时客户端到服务器的连接释放。客户端收到这个ACK之后进入FIN_WAIT2状态，等待服务器发出的FIN</li>
<li>服务端数据发送完成后发起一个连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），进入LAST_ACK状态，等待客户端确认</li>
<li>客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ol>
<p>为什么不能三次？<br>三次情况即为合并中间两次，但是在客户端数据发送完成后，服务端数据很有可能没有发送完，必须要等到服务端数据也发送完成才能断开服务端到客户端的连接</p>
<p>为什么最后客户端要等待两个MSL（最大报文生存时间）？<br>保证客户端最后一个ACK丢失时能够重传。</p>
<h3><span id="可靠">可靠</span></h3><h4><span id="校验和">校验和</span></h4><p>用于检验数据在传输过程中是否被修改。<br>占16位，计算方法为：在数据传输的过程中，将发送的数据段都当做一个16位的整数。<strong>逐整数相加，进位加到末尾，最后取反，再加下一个数</strong><br><img src="/../pic/blog_computer_network_tcp_checksum.jpg" alt="校验和计算"></p>
<h4><span id="序列号">序列号</span></h4><p>序列号是TCP传输时将数据按字节的编号<br>基于序列号的确认应答机制（ACK&#x3D;x+1）能够知道当前收到了哪些数据以及下一次的数据从哪个字节开始发送。<br>通过序列号还能是接收到的数据按序排列，同时也能够根据这个序号去掉重复的字节，也是对可靠性的一个保证</p>
<h4><span id="重传机制">重传机制</span></h4><h5><span id="超时重传">超时重传</span></h5><p>发送方发出一个数据后，维护一个计时器，在指定时间内没有收到对发出数据的ACK，则视为报文段丢失，发送端此时重新发送超时的报文段,这个时间延迟是动态变化的</p>
<h5><span id="快速重传">快速重传</span></h5><p>收到三个重复的ACK，表明当前的ACK确认的报文段已丢失，进行重传</p>
<h4><span id="流量控制">流量控制</span></h4><p>TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。<br>这个机制的实现是基于TCP窗口的。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<h4><span id="拥塞控制">拥塞控制</span></h4><p><img src="/../pic/blog_computer_network_tcp_congestion_control.jpg" alt="拥塞控制流程"></p>
<p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，<strong>发送窗口可能小于拥塞窗口</strong>。<br>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<br>当cwnd&lt; ssthresh时，使用慢开始算法。<br>当cwnd&gt; ssthresh时，改用拥塞避免算法。<br>当cwnd&#x3D; ssthresh时，慢开始与拥塞避免算法任意</p>
<p>MSS 是最大报文长度，作为拥塞窗口变化的最小单位</p>
<h3><span id="报文格式">报文格式</span></h3><h3><span id="安全性分析">安全性分析</span></h3>
    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 Cleaners&#39; Blog</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>