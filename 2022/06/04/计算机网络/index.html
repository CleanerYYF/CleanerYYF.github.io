<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>Cleaners&#39; Blog | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Cleaners&#39; Blog</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            计算机网络
        </div>
        <div class="post-meta">
            2022-06-04
        </div>
    

    <div class="post-md">
        <p><img src="/../pic/blog_computer_network.jpg" alt="计算机网络"></p>
<blockquote>
<p>主要参考经典教材与本科期间个人所学，基于目前广泛使用的TCP&#x2F;IP协议族，自顶向下分析各个常见网络协议及其安全问题</p>
</blockquote>
<p>[toc]</p>
<h1><span id="应用层">应用层</span></h1><h2><span id="dns">DNS</span></h2><p>《计算机网络-自顶向下方法》P87</p>
<h3><span id="解决的问题">解决的问题</span></h3><p>DNS协议又叫域名解析协议，是因特网目录服务中的核心协议。<br>因特网目录服务的产生是为了解决大规模网络环境中32位的IP地址难以管理的问题，通过<strong>分布式、层次化的数据库系统</strong>维护用户易于记忆的域名和IP协议能够识别的主机IP地址之间的<strong>映射关系</strong>。DNS系统的结构如下：<br><img src="/../pic/blog_computer_network_DNS2.jpg" alt="DNS系统结构"><br>DNS协议的作用就是提供这种域名到IP地址的转换（<strong>域名解析</strong>）</p>
<h3><span id="报文格式">报文格式</span></h3><p><img src="/../pic/blog_computer_network_DNS1.jpg" alt="DNS报文"><br>具体细节参考《计算机网络-自顶向下方法》P94-p95</p>
<h3><span id="协议运转">协议运转</span></h3><p>域名对应主机，采用树状结构命名，不同域名等级之间用”.”分隔，从左至右，域名等级逐渐提升，解析过程从右至左，一级解析一部分。<br>DNS中有两种解析方式：</p>
<ul>
<li>递归：主机到本地域名服务器为递归查询</li>
<li>迭代：本地DNS服务器到根DNS服务器、顶级域DNS服务器、权威DNS服务器为迭代查询</li>
</ul>
<h3><span id="安全攻击">安全攻击</span></h3><p><img src="/../pic/blog_computer_network_DNS3.jpg" alt="针对DNS的安全攻击"></p>
<ul>
<li>欺骗、劫持和钓鱼都是建立在中间人攻击的基础上，由于中间人对PC的响应更快，PC会丢弃真正的响应包（签名）</li>
<li>缓存投毒指的是通过虚假的DNS查询响应数据包，使本地DNS服务器缓存错误的映射关系，可以通过使用随机的子域名发起查询，并冒充更高级别的域名服务器发送响应报文，毒化更高级别的域名IP地址。（采用公钥密码进行签名、随机端口）</li>
<li>还可以通过DOS攻击破坏服务器可用性（在服务器部署防dos插件（汝Fail2Ban）即可）</li>
</ul>
<h2><span id="http">Http</span></h2><p>《计算机网络-自顶向下方法》P65</p>
<h3><span id="解决的问题">解决的问题</span></h3><p>web应用已经是大多数用户接入因特网的主要方式，能够按需主动搜索得到想要的信息<br>http是web应用的应用层协议，主要解决web应用中本地主机与远程主机超文本（图片、文本、音频等）传输的问题</p>
<h3><span id="报文格式">报文格式</span></h3><p>现行网络环境下的http绝大多数都通过TLS加密，通过Wireshark无法抓包查看</p>
<h4><span id="请求报文">请求报文：</span></h4><p><img src="/../pic/blog_computer_network_http2.jpg" alt="http请求报文格式"><br><img src="/../pic/blog_computer_network_http3.png" alt="http请求报文抓包"><br>请求报文分为三个部分：</p>
<ol>
<li>请求行：方法（get、post、head、options、put、delete、connect）</li>
<li>首部行：请求行之外的键值对</li>
<li>实体主体：传输的数据，比如Post方法携带的数据，get方法此部分为空</li>
</ol>
<p>响应报文：<br><img src="/../pic/blog_computer_network_http1.jpg" alt="http响应报文格式"><br><img src="/../pic/blog_computer_network_http4.jpg" alt="http响应报文抓包"><br>分为三个部分：</p>
<ol>
<li>状态行：版本、状态码、短语（OK、NOT FOUND等）</li>
<li>首部行：键值对</li>
<li>实体体：响应的数据</li>
</ol>
<h3><span id="请求方法">请求方法</span></h3><p>http有8种请求方法，最常见的为以下2种</p>
<h4><span id="get">Get</span></h4><p>GET方法用于使用给定的URI从给定服务器中<strong>检索信息</strong>，即从指定资源中<strong>请求数据</strong>。<br>使用GET方法的请求应该只是检索数据，并且<strong>不应对数据产生其他影响</strong>。<br>Get数据位于url上，可以缓存，没有长度限制（但是浏览器对url有长度限制），处理敏感数据时不能用Get</p>
<h4><span id="post">Post</span></h4><p>POST方法用于<strong>将数据发送到服务器</strong>以创建或更新资源，它要求服务器确认请求中包含的内容作为由URL区分的Web资源的另一个下属。</p>
<p>POST请求不会被缓存，请求对数据长度没有限制；无法从浏览器历史记录中查找到POST请求。</p>
<h3><span id="状态维持">状态维持</span></h3><p>http是一个无状态的协议，也就是说用户对同一个服务器不同页面的访问是无关的，这与用户在网页上的顺序操作流程是冲突的（如：登录 &#x3D;&#x3D;&gt; 获得个人数据 &#x3D;&#x3D;&gt;修改个人数据），所以需要用一定的机制解决这一问题。最基本的解决方案就使用Cookie</p>
<h4><span id="cookie">Cookie</span></h4><ol>
<li>用户首次访问服务器时由服务器生成，直接用键值对保存用户信息</li>
<li>首次http返回消息的首部行中携带，发送给客户端，并由客户端（一般是浏览器）保存</li>
<li>用户再次发起访问时在http首部行中携带cookie，服务器得到cookie得到用户身份信息，返回用户个性化页面</li>
</ol>
<h4><span id="非cookie的状态维持">非cookie的状态维持</span></h4><p>基于cookie扩展的状态维持主要思路是把cookie作为一个传输身份认证信息的容器，改变身份认证的机制，避免客户端保存直接的用户数据</p>
<ol>
<li><strong>Session</strong>： 针对于每一次会话，服务器通过用户信息生成一个键值对，键为与用户身份一一对应的sessionId，值为用户的身份信息，客户端只用保存SessionId，处理后续请求时服务器通过sessionId即可获得用户个人数据，避免了用户个人信息泄露，可以结合数据库缓存技术。<br>session机制可以脱离cookie实现。</li>
<li><strong>Token</strong>：将用户信息通过拼接、签名、完整性Hash值、加密等技术处理之后在客户端保存，避免用户信息泄露，服务器收到后进行解密、验证完整性、验证签名、得到拼接数据，即可得到用户个人信息。<br>需要说明对于session和token的传输时保存需要谨慎设置，比如放到cookie中容易收到CSRF攻击<h3><span id="web缓存">web缓存</span></h3>web缓存器也叫做代理服务器，是在一定场景下代替web服务器对web请求做出响应的中间（Client和Server之间）web实体。配置web缓存服务器的好处有：</li>
<li>减少请求响应时间</li>
<li>减少公网上的流量，改善整个网络性能<h4><span id="缓存场景下web请求响应过程">缓存场景下web请求响应过程</span></h4><strong>最原始场景：</strong></li>
<li>请求发送到web缓存</li>
<li>缓存检查是否有被请求的对象<blockquote>
<p>web缓存中有对应的对象，直接通过缓存进行响应<br>web缓存中没有对应的对象，缓存向web服务器发起请求，收到来自服务器的响应后缓存器响应最初web请求并将响应对象缓存起来</p>
</blockquote>
</li>
</ol>
<p>缓存器和服务器的对象往往存在时效性不一致问题，比如服务器数据更新后缓存器并没有更新，所以原始场景下长期存储对象并直接进行响应的做法在大部分场景下是不合理的</p>
<p><strong>条件GET：</strong></p>
<p><strong>设置：</strong></p>
<blockquote>
<ol>
<li>缓存中记录缓存对象最后一次修改时间。</li>
<li>有缓存时，缓存器向服务器发起条件Get请求（首部行包含If-Modified-Since），用于查询当前缓存的对象是否被更新</li>
<li>服务器收到这个请求报文有两个动作：</li>
</ol>
<ul>
<li>有更新：返回最新数据，包含修改时间</li>
<li>没有更新：返回实体部分为空（即只包含状态行和首部行的响应）</li>
</ul>
</blockquote>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 Cleaners&#39; Blog</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>